import{j as p,F as h,p as o,q as s,c as d,m as l}from"./library.MDn1VkXg.js";import{A as c}from"./AbstractID3Parser.COOd5Mzd.js";import{I as u}from"./ID3v2Parser.DIx2C7sD.js";import"./jsx-runtime.D_zvdyIk.js";import"./title.Zzc6FAcR.js";import"./index.DQLiH3RP.js";import"./createLucideIcon.DxLV4sYg.js";import"./button.Db3GhhwO.js";import"./card.gw5NK2rv.js";import"./dropdown-menu.COVBS5Vz.js";import"./index.CKCoq1tz.js";import"./index.B8Cg28y-.js";import"./index.C-Vi51-h.js";import"./index.CKz0Jdri.js";import"./index.CNoT2JK1.js";import"./dialog.CUSjS07t.js";import"./input.CNO_L4t5.js";import"./index.Bv7MI9QC.js";import"./client.BsjXsuL3.js";import"./loader-circle.BgR7_kSm.js";import"./trash-2.4YVattyp.js";const i={len:12,get:(e,t)=>({id:h.get(e,t),size:p.get(e,t+4)})},k={len:16,get:(e,t)=>({fileSize:o.get(e,t),metadataPointer:o.get(e,t+8)})},g={len:40,get:(e,t)=>({formatVersion:s.get(e,t),formatID:s.get(e,t+4),channelType:s.get(e,t+8),channelNum:s.get(e,t+12),samplingFrequency:s.get(e,t+16),bitsPerSample:s.get(e,t+20),sampleCount:o.get(e,t+24),blockSizePerChannel:s.get(e,t+32)})},n=d("music-metadata:parser:DSF");class z extends l("DSD"){}class U extends c{async postId3v2Parse(){const t=this.tokenizer.position,r=await this.tokenizer.readToken(i);if(r.id!=="DSD ")throw new z("Invalid chunk signature");this.metadata.setFormat("container","DSF"),this.metadata.setFormat("lossless",!0),this.metadata.setAudioOnly();const a=await this.tokenizer.readToken(k);if(a.metadataPointer===BigInt(0))n("No ID3v2 tag present");else return n(`expect ID3v2 at offset=${a.metadataPointer}`),await this.parseChunks(a.fileSize-r.size),await this.tokenizer.ignore(Number(a.metadataPointer)-this.tokenizer.position-t),new u().parse(this.metadata,this.tokenizer,this.options)}async parseChunks(t){for(;t>=i.len;){const r=await this.tokenizer.readToken(i);switch(n(`Parsing chunk name=${r.id} size=${r.size}`),r.id){case"fmt ":{const a=await this.tokenizer.readToken(g);this.metadata.setFormat("numberOfChannels",a.channelNum),this.metadata.setFormat("sampleRate",a.samplingFrequency),this.metadata.setFormat("bitsPerSample",a.bitsPerSample),this.metadata.setFormat("numberOfSamples",a.sampleCount),this.metadata.setFormat("duration",Number(a.sampleCount)/a.samplingFrequency);const m=a.bitsPerSample*a.samplingFrequency*a.channelNum;this.metadata.setFormat("bitrate",m);return}default:this.tokenizer.ignore(Number(r.size)-i.len);break}t-=r.size}}}export{z as DsdContentParseError,U as DsfParser};
